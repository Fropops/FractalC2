@using Shared
@using WebCommander.Models
@using WebCommander.Services
@using WebCommander.Helpers
@inject AgentService AgentService
@implements IDisposable

<div class="topology-container">
    <svg width="@svgWidth" height="@svgHeight" viewBox="0 0 @svgWidth @svgHeight" style="min-width: @(svgWidth)px; display: block; margin: 0 auto;">
        <!-- TeamServer Node -->
        <g transform="translate(@(svgWidth / 2), 50)">
            <!-- Server Rack Icon -->
            <rect x="-20" y="-20" width="40" height="40" rx="4" fill="#1e293b" stroke="#3b82f6" stroke-width="2"/>
            <line x1="-15" y1="-8" x2="15" y2="-8" stroke="#334155" stroke-width="2"/>
            <line x1="-15" y1="2" x2="15" y2="2" stroke="#334155" stroke-width="2"/>
            <line x1="-15" y1="12" x2="15" y2="12" stroke="#334155" stroke-width="2"/>
            <!-- Status Lights -->
            <circle cx="12" cy="-8" r="1.5" fill="#10b981"/>
            <circle cx="12" cy="2" r="1.5" fill="#10b981"/>
            <circle cx="12" cy="12" r="1.5" fill="#10b981"/>
            
            <text x="0" y="35" text-anchor="middle" fill="#e5e7eb" font-size="12">TeamServer</text>
        </g>

        @foreach (var host in hosts)
        {
            var hostX = host.X;
            var hostY = host.Y;
            
            <!-- Host Box -->
            <g transform="translate(@hostX, @hostY)">
                <rect x="@(-(host.Width / 2))" y="-60" width="@host.Width" height="@(60 + host.Agents.Count * 35)" 
                      rx="8" fill="#1f2937" stroke="#374151" stroke-width="2"/>
                
                <!-- Host Icon and Name -->
                <!-- Host Icon and Name -->
                <foreignObject x="-12" y="-50" width="24" height="24">
                     <div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; justify-content: center; align-items: center; height: 100%;">
                        <i class="bi @(host.OsType == OsType.Linux ? "bi-terminal-fill" : "bi-windows")" style="font-size: 20px; color: #9ca3af;"></i>
                    </div>
                </foreignObject>
                <text x="0" y="-15" text-anchor="middle" fill="#e5e7eb" font-size="11" font-weight="bold">@host.Hostname</text>
                
                <!-- Agents in this host -->
                @for (int i = 0; i < host.Agents.Count; i++)
                {
                    var agent = host.Agents[i];
                    var agentY = i * 35 + 10;
                    var agentColor = agent.IsAlive ? "#10b981" : "#6b7280";
                    var badgeColor = agent.IsAlive ? "#10b981" : "#ef4444";
                    var agentId = $"agent-{agent.Id}";
                    var agentLabel = string.IsNullOrEmpty(agent.UserName) 
                        ? $"{agent.Name}"
                    : $"{agent.Name} ({agent.UserName})";
                    var agentIcon = "‚öôÔ∏è";
                    
                    <g transform="translate(@host.AgentStartX, @agentY)" class="agent-node" data-agent-id="@agent.Id" @onclick="@((MouseEventArgs e) => ShowAgentMenu(agent.Id, e))" @onclick:stopPropagation="true">
                        <!-- Tooltip -->
                        <title>@($"ID: {agent.Id}\nName: {agent.Name}\nUser: {agent.UserName}\nProcess: {agent.ProcessName} ({agent.ProcessId})\nIntegrity: {agent.Integrity}\nArch: {agent.Architecture}\nEndPoint: {agent.EndPoint}\nLast Seen: {agent.LastSeen:yyyy-MM-dd HH:mm:ss}")</title>
                        
                        <!-- Status badge (left of icon) -->
                        <circle cx="-6" cy="0" r="6" fill="@badgeColor" stroke="#1f2937" stroke-width="1.5"/>
                        
                        <!-- Agent icon (gear) -->
                        <text x="0" y="5" font-size="16" fill="@agentColor">@agentIcon</text>
                        
                        <!-- Agent Label and Integrity Icon -->
                        <text x="20" y="4" fill="#e5e7eb" font-size="10">
                            @agentLabel
                            @if (agent.Integrity == IntegrityLevel.High || agent.Integrity == IntegrityLevel.System)
                            {
                                <tspan dx="5" font-size="12">üõ°Ô∏è</tspan>
                            }
                        </text>
                    </g>
                }
            </g>
            
            @for (int i = 0; i < host.Agents.Count; i++)
            {
                var agent = host.Agents[i];
                
                // Only draw TeamServer connection if agent is active, has no RelayId (direct connection)
                if (agent.IsAlive && string.IsNullOrEmpty(agent.RelayId))
                {
                    var agentY = hostY + i * 35 + 10;
                    
                    var conn = ConnexionUrl.FromString(agent.EndPoint);
                    var isListener = conn.IsValid && conn.Mode == ConnexionMode.Listener;
                    
                    // Target position (TeamServer)
                    var targetX = (double)(svgWidth / 2);
                    var targetY = 72.0;
                    
                    // Agent position
                    var agentX = (double)(hostX + host.AgentStartX + 8);
                    var agentYDouble = (double)agentY;
                    
                    // Calculate vector and length
                    var dx = agentX - targetX;
                    var dy = agentYDouble - targetY;
                    var length = Math.Sqrt(dx * dx + dy * dy);
                    var arrowLen = 8.0;
                    
                    // Calculate offset for arrowhead
                    var offsetX = (dx / length) * arrowLen;
                    var offsetY = (dy / length) * arrowLen;
                    
                    double startX, startY, endX, endY;
                    
                    if (isListener)
                    {
                        // Listener: Arrow at Agent. Line starts at TS, ends short of Agent.
                        startX = targetX;
                        startY = targetY;
                        endX = agentX - offsetX;
                        endY = agentYDouble - offsetY;
                    }
                    else
                    {
                        // Client: Arrow at TS. Line starts short of TS, ends at Agent.
                        startX = targetX + offsetX;
                        startY = targetY + offsetY;
                        endX = agentX;
                        endY = agentYDouble;
                    }
                    
                    <line x1="@startX" y1="@startY" x2="@endX" y2="@endY" 
                          stroke="#60a5fa" stroke-width="2" opacity="0.6"/>
                    
                    // Calculate arrow angle
                    var angle = Math.Atan2(dy, dx) * 180 / Math.PI;
                    
                    if (isListener)
                    {
                        // Arrow points to agent (Listener mode)
                        <polygon points="0,-4 8,0 0,4" fill="#60a5fa" opacity="0.8" 
                                 transform="translate(@endX, @endY) rotate(@angle)"/>
                    }
                    else
                    {
                        // Arrow points to TeamServer (Client mode)
                        <polygon points="0,-4 8,0 0,4" fill="#60a5fa" opacity="0.8" 
                                 transform="translate(@startX, @startY) rotate(@(angle + 180))"/>
                    }
                    
                    var midX = (startX + endX) / 2;
                    var midY = (startY + endY) / 2;
                    @:<text x="@midX" y="@midY" text-anchor="middle" fill="#60a5fa" font-size="9">@conn.ProtocolString</text>
                }
            }
        }
        
        @foreach (var link in agentLinks)
        {
            var startX = link.ParentX;
            var startY = link.ParentY;
            var endX = link.ChildX;
            var endY = link.ChildY;
            
            <line x1="@startX" y1="@startY" x2="@endX" y2="@endY" 
                  stroke="#f59e0b" stroke-width="2" opacity="0.6" stroke-dasharray="5,5"/>
            
            // Calculate arrow angle
            var dx = endX - startX;
            var dy = endY - startY;
            var angle = Math.Atan2(dy, dx) * 180 / Math.PI;
            
            @if (link.IsListener)
            {
                <polygon points="0,-4 8,0 0,4" fill="#f59e0b" opacity="0.8" 
                         transform="translate(@endX, @endY) rotate(@angle)"/>
            }
            else
            {
                <polygon points="0,-4 8,0 0,4" fill="#f59e0b" opacity="0.8" 
                         transform="translate(@startX, @startY) rotate(@(angle + 180))"/>
            }
            
            @:<text x="@((startX + endX) / 2)" y="@((startY + endY) / 2)" text-anchor="middle" fill="#f59e0b" font-size="9">@link.Protocol</text>
        }
    </svg>

    <!-- Agent Context Menu -->
    @if (!string.IsNullOrEmpty(selectedAgentId))
    {
        <div class="agent-menu" style="position: fixed; left: @menuX; top: @menuY; z-index: 1000;">
            <div class="card shadow-lg" style="min-width: 200px;">
                <div class="card-body p-2">
                    <div class="list-group list-group-flush">
                        @if (selectedAgentIsAlive)
                        {
                            <a href="/terminal/@selectedAgentId" class="list-group-item list-group-item-action py-2">
                                <i class="bi bi-chat-dots me-2"></i>Interact
                            </a>
                        }
                        else
                        {
                            <div class="list-group-item list-group-item-action py-2 disabled text-muted">
                                <i class="bi bi-chat-dots me-2"></i>Interact (Offline)
                            </div>
                        }
                        <a href="/agent-info/@selectedAgentId" class="list-group-item list-group-item-action py-2">
                            <i class="bi bi-info-circle me-2"></i>View Info
                        </a>
                        <a href="/agent-tasks/@selectedAgentId" class="list-group-item list-group-item-action py-2">
                            <i class="bi bi-list-task me-2"></i>Tasks
                        </a>
                        <a href="/loots/@selectedAgentId" class="list-group-item list-group-item-action py-2">
                            <i class="bi bi-folder2-open me-2"></i>Loots
                        </a>
                    </div>
                </div>
            </div>
        </div>
    }
</div>

<!-- Overlay to close menu when clicking outside -->
@if (!string.IsNullOrEmpty(selectedAgentId))
{
    <div class="menu-overlay" @onclick="CloseAgentMenu" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 999;"></div>
}

<style>
    .topology-container {
        background: #111827;
        border-radius: 12px;
        padding: 1rem;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: auto;
        box-sizing: border-box;
    }

    .agent-node {
        cursor: pointer;
    }

    .agent-node:hover {
        opacity: 0.8;
    }

    .agent-active .agent-icon {
        fill: #10b981;
    }

    .agent-inactive .agent-icon {
        fill: #6b7280;
    }

    .agent-menu {
        animation: fadeIn 0.2s ease-in-out;
    }

    @@keyframes fadeIn {
        from {
            opacity: 0;
            transform: scale(0.95);
        }
        to {
            opacity: 1;
            transform: scale(1);
        }
    }
</style>

@code {
    private List<HostNode> hosts = new();
    private List<AgentLink> agentLinks = new();
    private System.Threading.Timer? _timer;
    private string selectedAgentId = "";
    private bool selectedAgentIsAlive = false;
    private string menuX = "0px";
    private string menuY = "0px";
    private int svgWidth = 1200;
    private int svgHeight = 600;

    [Inject]
    private NavigationManager Navigation { get; set; } = default!;

    protected override void OnInitialized()
    {
        AgentService.OnAgentsUpdated += UpdateTopology;
        UpdateTopology();
        
        _timer = new System.Threading.Timer(async _ =>
        {
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    private void UpdateTopology()
    {
        var agents = AgentService.GetAgents();
        
        // Group agents by hostname
        var hostGroups = agents.GroupBy(a => a.Metadata?.Hostname ?? "Unknown").ToList();
        
        hosts.Clear();
        agentLinks.Clear();
        
        // First pass: Create hosts and calculate their required widths
        int maxHostWidth = 200;
        
        for (int i = 0; i < hostGroups.Count; i++)
        {
            var group = hostGroups[i];
            
            var hostNode = new HostNode
            {
                Hostname = group.Key,
                Agents = new List<AgentNode>(),
                OsType = group.FirstOrDefault()?.Metadata?.OsType ?? OsType.Windows
            };
            
            // Calculate width based on Hostname
            int nameWidth = (int)(hostNode.Hostname.Length * 8); // Approx 8px per char
            int maxLabelWidth = 0;

            // Sort agents: direct TeamServer connections first, then relayed agents
            var sortedAgents = group.OrderBy(a => string.IsNullOrEmpty(a.RelayId) ? 0 : 1).ToList();
            
            foreach (var agent in sortedAgents)
            {
                var agentNode = new AgentNode
                {
                    Id = agent.Id,
                    ShortId = agent.Id.Length > 8 ? agent.Id.Substring(0, 8) : agent.Id,
                    Name = agent.Metadata?.Name ?? "Unknown",
                    IsAlive = AgentHelper.IsAgentAlive(agent, agents) ?? false,
                    EndPoint = agent.Metadata?.EndPoint ?? "",
                    RelayId = agent.RelayId,
                    Integrity = agent.Metadata?.Integrity ?? IntegrityLevel.Medium,
                    UserName = agent.Metadata?.UserName ?? "",
                    ProcessName = agent.Metadata?.ProcessName ?? "",
                    ProcessId = agent.Metadata?.ProcessId ?? 0,
                    Architecture = agent.Metadata?.Architecture ?? "",
                    LastSeen = agent.LastSeen,
                    Links = agent.Links ?? new List<string>()
                };
                hostNode.Agents.Add(agentNode);
                
                // Calculate width based on Agent Name + ShortId + Shield
                string label = string.IsNullOrEmpty(agentNode.UserName) 
                    ? $"{agentNode.Name} ({agentNode.ShortId})"
                    : $"{agentNode.UserName} - {agentNode.Name} ({agentNode.ShortId})";
                int labelWidth = (int)(label.Length * 4.5); // Approx 4.5px per char for 10px font
                if (agentNode.Integrity == IntegrityLevel.High || agentNode.Integrity == IntegrityLevel.System)
                {
                    labelWidth += 25; // Space for shield
                }
                
                if (labelWidth > maxLabelWidth)
                {
                    maxLabelWidth = labelWidth;
                }
            }
            
            // Calculate AgentStartX to center the longest agent line
            // Line structure: [Badge(-6)] [Icon(0)] [Text(20)]
            // Left edge (Badge left): AgentStartX - 12
            // Right edge (Text right): AgentStartX + 20 + maxLabelWidth
            // Centering: AgentStartX = -4 - maxLabelWidth/2
            hostNode.AgentStartX = -4 - (maxLabelWidth / 2);
            
            int contentWidth = Math.Max(nameWidth, 32 + maxLabelWidth);
            hostNode.Width = contentWidth + 30; // Reduced to 15px padding on each side
            maxHostWidth = Math.Max(maxHostWidth, hostNode.Width);
            
            hosts.Add(hostNode);
        }

        // Calculate positions for hosts in a grid
        int hostsPerRow = Math.Max(1, (int)Math.Ceiling(Math.Sqrt(hostGroups.Count)));
        // Ensure minimum width per host based on calculated max width
        int minSpacing = maxHostWidth + 20; // Reduced gap between hosts
        // Use a smaller base width for calculation to allow for more compact layout
        int spacing = Math.Max(minSpacing, 600 / (hostsPerRow + 1));
        
        // Calculate dynamic width
        svgWidth = Math.Max(600, (hostsPerRow + 1) * spacing);
        
        // Calculate dynamic height based on max agents in a host
        int maxAgents = hostGroups.Any() ? hostGroups.Max(g => g.Count()) : 0;
        int rows = (int)Math.Ceiling((double)hostGroups.Count / hostsPerRow);
        svgHeight = Math.Max(600, 200 + rows * (60 + maxAgents * 35 + 100)); // Add padding between rows

        // Recalculate spacing based on actual width if needed
        spacing = svgWidth / (hostsPerRow + 1);

        for (int i = 0; i < hosts.Count; i++)
        {
            var hostNode = hosts[i];
            int row = i / hostsPerRow;
            int col = i % hostsPerRow;
            
            hostNode.X = (col + 1) * spacing;
            hostNode.Y = 200 + row * (200 + (maxAgents > 5 ? (maxAgents - 5) * 35 : 0));
        }
        
        // Build agent-to-agent links using Links
        foreach (var host in hosts)
        {
            for (int i = 0; i < host.Agents.Count; i++)
            {
                var parentAgent = host.Agents[i];
                
                // Only create links if parent is active and has links
                if (parentAgent.IsAlive && parentAgent.Links != null)
                {
                    foreach (var childId in parentAgent.Links)
                    {
                        // Find the child agent
                        AgentNode? childAgent = null;
                        HostNode? childHost = null;
                        int childIndex = -1;
                        
                        foreach (var h in hosts)
                        {
                            for (int j = 0; j < h.Agents.Count; j++)
                            {
                                if (h.Agents[j].Id == childId)
                                {
                                    childAgent = h.Agents[j];
                                    childHost = h;
                                    childIndex = j;
                                    break;
                                }
                            }
                            if (childAgent != null) break;
                        }
                        
                        // Only draw link if child agent is also active
                        if (childAgent != null && childHost != null && childAgent.IsAlive)
                        {
                            var conn = ConnexionUrl.FromString(childAgent.EndPoint);
                            
                            agentLinks.Add(new AgentLink
                            {
                                ParentX = host.X + host.AgentStartX + 8,
                                ParentY = host.Y + i * 35 + 10,
                                ChildX = childHost.X + childHost.AgentStartX + 8,
                                ChildY = childHost.Y + childIndex * 35 + 10,
                                Protocol = conn.ProtocolString,
                                IsListener = conn.IsValid && conn.Mode == ConnexionMode.Listener
                            });
                        }
                    }
                }
            }
        }
        
        InvokeAsync(StateHasChanged);
    }

    private void ShowAgentMenu(string agentId, MouseEventArgs e)
    {
        selectedAgentId = agentId;
        
        // Find agent status
        selectedAgentIsAlive = false;
        foreach (var host in hosts)
        {
            var agent = host.Agents.FirstOrDefault(a => a.Id == agentId);
            if (agent != null)
            {
                selectedAgentIsAlive = agent.IsAlive;
                break;
            }
        }
        
        // Position menu at mouse cursor
        menuX = $"{e.ClientX}px";
        menuY = $"{e.ClientY}px";
        StateHasChanged();
    }

    private void CloseAgentMenu()
    {
        selectedAgentId = "";
        StateHasChanged();
    }

    public void Dispose()
    {
        AgentService.OnAgentsUpdated -= UpdateTopology;
        _timer?.Dispose();
    }

    private class HostNode
    {
        public string Hostname { get; set; } = "";
        public OsType OsType { get; set; }
        public int X { get; set; }
        public int Y { get; set; }
        public int Width { get; set; } = 200;
        public int AgentStartX { get; set; }
        public List<AgentNode> Agents { get; set; } = new();
    }

    private class AgentNode
    {
        public string Id { get; set; } = "";
        public string ShortId { get; set; } = "";
        public string Name { get; set; } = "";
        public bool IsAlive { get; set; }
        public string EndPoint { get; set; } = "";
        public string? RelayId { get; set; }
        public IntegrityLevel Integrity { get; set; }
        public string UserName { get; set; } = "";
        public string ProcessName { get; set; } = "";
        public int ProcessId { get; set; }
        public string Architecture { get; set; } = "";
        public DateTime LastSeen { get; set; }
        public List<string> Links { get; set; } = new();
    }

    private class AgentLink
    {
        public int ParentX { get; set; }
        public int ParentY { get; set; }
        public int ChildX { get; set; }
        public int ChildY { get; set; }
        public string Protocol { get; set; } = "";
        public bool IsListener { get; set; }
    }
}
