@page "/terminal/{AgentId}"
@using WebCommander.Models
@using WebCommander.Services
@using WebCommander.Helpers
@using WebCommander.Components
@inject AgentService AgentService
@inject NavigationManager NavigationManager
@inject CommandService CommandService

<PageTitle>Terminal - @(agent?.Metadata?.ImplantId ?? "Unknown")</PageTitle>

<div class="terminal-page-container">
    @if (agent == null)
    {
        <p>Agent not found</p>
    }
    else
    {
        <div class="container-fluid mt-3">
            <AgentHeader Agent="@agent" 
                         AllAgents="@AgentService.GetAgents()"
                         ShowInteractButton="false"
                         ShowBackButton="true"
                         BackButtonText="Close"
                         OnBack="Close" />
        </div>
        
        <div class="terminal-container">
            <div class="terminal-output" @ref="terminalOutput">
                @foreach (var line in outputLines)
                {
                    <div class="terminal-line @GetLineClass(line.Type)">@line.Text</div>
                }
            </div>
            
            <div class="terminal-input-container">
                <span class="terminal-prompt">@(agent.Metadata?.ImplantId ?? "Unknown") &gt;</span>
                <input type="text" 
                       class="terminal-input" 
                       @bind="currentCommand" 
                       @bind:event="oninput"
                       @onkeydown="HandleKeyDown"
                       @ref="inputElement"
                       placeholder="Type a command..." />
            </div>
        </div>
    }
</div>

<style>
    .terminal-page-container {
        height: calc(100vh - 60px);
        display: flex;
        flex-direction: column;
    }

    .terminal-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        background-color: #1e1e1e;
        color: #d4d4d4;
        font-family: 'Consolas', 'Courier New', monospace;
        margin: 0 1rem 1rem 1rem;
        border-radius: 4px;
        overflow: hidden;
    }

    .terminal-output {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        font-size: 14px;
        line-height: 1.5;
    }

    .terminal-line {
        margin-bottom: 5px;
        white-space: pre-wrap;
        word-wrap: break-word;
    }

    .terminal-line.error {
        color: #f48771;
    }

    .terminal-line.warning {
        color: #dcdcaa;
    }

    .terminal-line.info {
        color: #4ec9b0;
    }

    .terminal-line.normal {
        color: #d4d4d4;
    }

    .terminal-input-container {
        background-color: #2d2d30;
        padding: 10px 20px;
        border-top: 1px solid #3e3e42;
        display: flex;
        align-items: center;
    }

    .terminal-prompt {
        color: #4ec9b0;
        margin-right: 10px;
        font-weight: bold;
    }

    .terminal-input {
        flex: 1;
        background-color: transparent;
        border: none;
        color: #d4d4d4;
        font-family: 'Consolas', 'Courier New', monospace;
        font-size: 14px;
        outline: none;
    }

    .terminal-input::placeholder {
        color: #6a6a6a;
    }

    .terminal-output::-webkit-scrollbar {
        width: 10px;
    }

    .terminal-output::-webkit-scrollbar-track {
        background: #1e1e1e;
    }

    .terminal-output::-webkit-scrollbar-thumb {
        background: #3e3e42;
        border-radius: 5px;
    }

    .terminal-output::-webkit-scrollbar-thumb:hover {
        background: #555;
    }
</style>

@code {
    public enum TerminalLineType
    {
        Normal,
        Error,
        Warning,
        Info
    }

    public class TerminalLine
    {
        public string Text { get; set; } = string.Empty;
        public TerminalLineType Type { get; set; } = TerminalLineType.Normal;
    }

    [Parameter]
    public string AgentId { get; set; } = string.Empty;

    private Agent? agent;
    private string currentCommand = string.Empty;
    private List<TerminalLine> outputLines = new();
    private HashSet<string> sentTaskIds = new();
    private Dictionary<string, string> taskCommands = new();
    private ElementReference terminalOutput;
    private ElementReference inputElement;

    protected override void OnInitialized()
    {
        agent = AgentService.GetAgents().FirstOrDefault(a => a.Id == AgentId);
        
        if (agent != null)
        {
            AddInfo($"Connected to agent {agent.Metadata?.ImplantId ?? "Unknown"}");
            AddInfo($"User: {agent.Metadata?.Desc}");
            AddInfo($"Architecture: {agent.Metadata?.Architecture}");
            AddInfo($"Process: {agent.Metadata?.ProcessName} (PID: {agent.Metadata?.ProcessId})");
            AddNormal("");
        }

        AgentService.OnAgentsUpdated += RefreshAgent;
        AgentService.OnAgentResult += HandleAgentResult;
    }

    private void RefreshAgent()
    {
        var updatedAgent = AgentService.GetAgents().FirstOrDefault(a => a.Id == AgentId);
        if (updatedAgent != null)
        {
            agent = updatedAgent;
            InvokeAsync(StateHasChanged);
        }
    }

    public void Dispose()
    {
        AgentService.OnAgentsUpdated -= RefreshAgent;
        AgentService.OnAgentResult -= HandleAgentResult;
    }

    private void AddNormal(string text)
    {
        outputLines.Add(new TerminalLine { Text = text, Type = TerminalLineType.Normal });
    }

    private void AddError(string text)
    {
        outputLines.Add(new TerminalLine { Text = text, Type = TerminalLineType.Error });
    }

    private void AddWarning(string text)
    {
        outputLines.Add(new TerminalLine { Text = text, Type = TerminalLineType.Warning });
    }

    private void AddInfo(string text)
    {
        outputLines.Add(new TerminalLine { Text = text, Type = TerminalLineType.Info });
    }

    private string GetLineClass(TerminalLineType type)
    {
        return type switch
        {
            TerminalLineType.Error => "error",
            TerminalLineType.Warning => "warning",
            TerminalLineType.Info => "info",
            _ => "normal"
        };
    }

    private void HandleAgentResult(AgentTaskResult result)
    {
        // Only display results for tasks sent by this terminal
        if (!sentTaskIds.Contains(result.Id))
            return;

        if (result.Status == AgentResultStatus.Completed)
        {
            // Get command name if available
            var commandName = taskCommands.TryGetValue(result.Id, out var cmd) ? cmd : "unknown";
            
            // Display header
            AddInfo($"Task {commandName} is {result.Status}");
            AddInfo("-------------------------------------------");
            
            if (!string.IsNullOrEmpty(result.Output))
            {
                AddNormal(result.Output);
            }
            if (!string.IsNullOrEmpty(result.Error))
            {
                AddError(result.Error);
            }
            AddNormal("");
            StateHasChanged();
            _ = ScrollToBottom();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await inputElement.FocusAsync();
        }
    }

    private async Task HandleKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !string.IsNullOrWhiteSpace(currentCommand))
        {
            // Store the command for later reference
            var commandToSend = currentCommand;
            
            // Add command to output
            AddNormal($"{agent?.Metadata?.ImplantId ?? "Unknown"} > {commandToSend}");
            
            // Send command
            var (message, taskId) = await CommandService.ParseAndSendAsync(commandToSend, AgentId);
            AddNormal(message);
            
            // Track task ID if command was sent successfully
            if (taskId != null)
            {
                sentTaskIds.Add(taskId);
                // Store command name (first word)
                var cmdName = commandToSend.Split(' ')[0];
                taskCommands[taskId] = cmdName;
            }
            
            // Clear input
            currentCommand = string.Empty;
            
            StateHasChanged();
            
            // Scroll to bottom
            await ScrollToBottom();
        }
    }

    private async Task ScrollToBottom()
    {
        await Task.Delay(50);
        // Note: In a real implementation, you'd use JSInterop to scroll
        // For now, the CSS overflow will handle it
    }

    private void Close()
    {
        NavigationManager.NavigateTo("/agents");
    }
}
